import streamlit as st
import pandas as pd
import plotly.express as px
from pythreejs import *
from specklepy.api.client import SpeckleClient
from specklepy.api.credentials import get_account_from_token

# 1. Imports and Setup
import data_extraction.facade_extractor as team_extractor  # Only import the extractor module
import pandas as pd
import plotly.express as px

from dashboards.dashboard import *

def metric_calc_daylight_factor(weight_residential, weight_work, residential_area_with_daylight, total_residential_area, work_area_with_daylight, total_work_area):
    return (
        weight_residential * (residential_area_with_daylight / total_residential_area) +
        weight_work * (work_area_with_daylight / total_work_area)
    )

def metric_calc_energy_ratio(energy_generation, energy_required_by_industrial_team):
    return energy_generation / energy_required_by_industrial_team

def metric_calc_panel_optimization(total_final_panel_area, total_initial_panel_area):
    return total_final_panel_area / total_initial_panel_area

def metric_interactive_calculator_panel_optimization(container, total_final_panel_area, total_initial_panel_area):
    with container:
        st.markdown("### Panel Optimization Calculator")
        total_final_panel_area_slider = st.slider("Total Final Panel Area (m²)", 0, int(total_final_panel_area), int(total_final_panel_area), help="Final panel area")
        total_initial_panel_area_slider = st.slider("Total Initial Panel Area (m²)", 1, int(total_initial_panel_area), int(total_initial_panel_area), help="Initial panel area")
        new_panel_optimization_value = metric_calc_panel_optimization(total_final_panel_area_slider, total_initial_panel_area_slider)
        st.markdown(f"### Resulting Ratio: {new_panel_optimization_value:.2f}")
        # Create dynamic sphere for panel optimization
        dynamic_panel_optimization_sphere = create_sphere_visualization(
            "dynamic-panel-optimization-sphere",
            new_panel_optimization_value,
            "Panel Optimization",
            height=200
        )
        st.components.v1.html(dynamic_panel_optimization_sphere, height=250)

def metric_interactive_calculator_daylight_factor(container, weight_residential, weight_work, residential_area_with_daylight, total_residential_area, work_area_with_daylight, total_work_area):
    with container:
        st.markdown("### Primary Daylight Factor & and Solar Loads Control for Residential Spaces and Work Spaces Calculator")
        residential_area_with_daylight_slider = st.slider("Daylit Residential Area (m²)", 0, 2000, int(residential_area_with_daylight), help="Daylit area in residential spaces")
        total_residential_area_slider = st.slider("Total Residential Area (m²)", 1, 2000, int(total_residential_area), help="Total area in residential spaces")
        work_area_with_daylight_slider = st.slider("Daylit Work Area (m²)", 0, 2000, int(work_area_with_daylight), help="Daylit area in work spaces")
        total_work_area_slider = st.slider("Total Work Area (m²)", 1, 2000, int(total_work_area), help="Total area in work spaces")
        new_daylight_value = (
            weight_residential * (residential_area_with_daylight_slider / total_residential_area_slider) +
            weight_work * (work_area_with_daylight_slider / total_work_area_slider)
        )
        st.markdown(f"### Resulting Ratio: {new_daylight_value:.2f}")
        # Create dynamic sphere for daylight
        dynamic_daylight_sphere = create_sphere_visualization(
            "dynamic-daylight-sphere",
            new_daylight_value,
            "Daylight Factor",
            height=200
        )
        st.components.v1.html(dynamic_daylight_sphere, height=250)

def metric_interactive_calculator_energy_ratio(container, energy_generation, energy_required_by_industrial_team):
    with container:
        st.markdown("### Energy Ratio Calculator")
        energy_generation_slider = st.slider("Energy Generation (kWh)", 0, 3000, int(energy_generation), help="Energy generated by building systems")
        energy_required_slider = st.slider("Energy Required (kWh)", 1, 2000, int(energy_required_by_industrial_team), help="Total energy required")
        new_energy_ratio = energy_generation_slider / energy_required_slider
        st.markdown(f"### Resulting Ratio: {new_energy_ratio:.2f}")
        # Create dynamic sphere for energy
        dynamic_energy_sphere = create_sphere_visualization(
            "dynamic-energy-sphere",
            new_energy_ratio,
            "Energy Ratio",
            height=200
        )
        st.components.v1.html(dynamic_energy_sphere, height=250)

def run(selected_team: str) -> None:
    # Extract data
    models, client, project_id = setup_speckle_connection()
    verified, team_data = team_extractor.extract(models, client, project_id, header=False, table=False, gauge=False, attribute_display=False)

    # Building Dashboard
    # Dashboard Header
    display_page_title(selected_team)
    team_extractor.display_data(extracted_data=team_data, verbose=False, header=True, show_table=True, gauge=False, simple_table=True)

    if not verified:
        st.error("Failed to extract data, proceeding with Example Data. Use Data Dashboard to Investigate.")
        team_extractor.display_data(extracted_data=team_data, header=False, show_table=False, gauge=True, simple_table=False)
        # Example data
        energy_generation = 1500  # kWh
        energy_required_by_industrial_team = 1000  # kWh

        weight_residential = 0.5
        weight_work = 0.5
        residential_area_with_daylight = 100
        total_residential_area = 200
        work_area_with_daylight = 150
        total_work_area = 300

        total_final_panel_area = 100
        total_initial_panel_area = 200

    else:
        # Extracted data
        energy_generation = team_data['EnergyGeneration']
        energy_required_by_industrial_team = team_data['EnergyRequiredByIndustrialTeam']
        weight_residential = 0.5
        weight_work = 0.5
        residential_area_with_daylight = team_data['ResidentialAreaWithDaylight']
        total_residential_area = team_data['TotalResidentialArea']
        work_area_with_daylight = team_data['WorkAreaWithDaylight']
        total_work_area = team_data['TotalWorkArea']

        total_final_panel_area = team_data['TotalFinalPanelArea']
        total_initial_panel_area = team_data['TotalInitialPanelArea']
    
    metrics = []

    daylight_factor_metric = Metric(
        "Primary Daylight Factor & and Solar Loads Control for Residential Spaces and Work Spaces",
        r'w_{resi}\frac{ResidentialAreaWithDaylight}{TotalResidentialArea} + w_{work}\frac{WorkAreaWithDaylight}{TotalWorkArea}',
        "Measures the proportion of floor area that receives daylight.",
        metric_interactive_calculator_daylight_factor,
        metric_calc_daylight_factor,
        weight_residential, 
        weight_work, 
        residential_area_with_daylight, 
        total_residential_area, 
        work_area_with_daylight, 
        total_work_area
    )
    metrics.append(daylight_factor_metric)

    panel_optimization_metric = Metric(
        "Panel Optimization",
        r'\frac {Total Final Panel Area}{Total Initial Panel Area}',
        "Measures the efficiency of panel area usage.",
        metric_interactive_calculator_panel_optimization,
        metric_calc_panel_optimization,
        total_final_panel_area,
        total_initial_panel_area
    )
    metrics.append(panel_optimization_metric)
    
    energy_ratio_metric = Metric(
        "Energy Generation Ratio",
        r'\frac{Energy Produced}{Energy Needed}',
        "Measures the ratio of energy generation to energy requirements.",
        metric_interactive_calculator_energy_ratio,
        metric_calc_energy_ratio,
        energy_generation,
        energy_required_by_industrial_team
    )
    metrics.append(energy_ratio_metric)

    # Display Formulas and Explanations
    display_formula_section_header(selected_team)
    
    # Metrics Display - Updated with correct metrics
    metrics_display_container = st.container()
    display_st_metric_values(metrics_display_container, metrics)
    
    metrics_visualization_container = st.container()
    display_metric_visualizations(metrics_visualization_container, metrics, add_text=True, add_sphere=True)

    # Interactive Calculators
    metric_interactive_calculator_container = st.container()
    display_interactive_calculators(metric_interactive_calculator_container, metrics, grid=True)
